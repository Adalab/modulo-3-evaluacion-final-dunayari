{"ast":null,"code":"// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\nconst log = require('proc-log');\n\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\n\nconst CanPlaceDep = require('./can-place-dep.js');\n\nconst {\n  KEEP,\n  CONFLICT\n} = CanPlaceDep;\n\nconst debug = require('./debug.js');\n\nconst Link = require('./link.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst peerEntrySets = require('./peer-entry-sets.js');\n\nclass PlaceDep {\n  constructor(options) {\n    const {\n      dep,\n      edge,\n      parent = null\n    } = options;\n    this.name = edge.name;\n    this.dep = dep;\n    this.edge = edge;\n    this.canPlace = null;\n    this.target = null;\n    this.placed = null; // inherit all these fields from the parent to ensure consistency.\n\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    } = parent || options;\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    });\n    this.children = [];\n    this.parent = parent;\n    this.peerConflict = null;\n    this.checks = new Map();\n    this.place();\n  }\n\n  place() {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks\n    } = this; // nothing to do if the edge is fine as it is\n\n    if (edge.to && !edge.error && !explicitRequest && !updateNames.includes(edge.name) && !this.isVulnerable(edge.to)) {\n      return;\n    } // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n\n\n    const start = this.getStartNode();\n    let canPlace = null;\n    let canPlaceSelf = null;\n\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name);\n\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue;\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest\n      });\n      checks.set(target, cpd); // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd;\n      } // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n\n\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd;\n      } else {\n        break;\n      } // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n\n\n      if (dep.errors.length) {\n        break;\n      } // nest packages like npm v1 and v2\n      // very disk-inefficient\n\n\n      if (legacyBundling) {\n        break;\n      } // when installing globally, or just in global style, we never place\n      // deps above the first level.\n\n\n      if (globalStyle) {\n        const rp = target.resolveParent;\n\n        if (rp && rp.isProjectRoot) {\n          break;\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf\n    });\n    this.current = edge.to; // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict();\n      } // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n\n\n      if (!canPlaceSelf) {\n        this.warnPeerConflict();\n        return;\n      }\n\n      this.canPlace = canPlaceSelf;\n    } // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n\n\n    this.placeInTree();\n  }\n\n  placeInTree() {\n    const {\n      dep,\n      canPlace,\n      edge\n    } = this;\n    /* istanbul ignore next */\n\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree');\n      });\n      return;\n    }\n\n    const {\n      target\n    } = canPlace;\n    log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description, `for: ${this.edge.from.package._id || this.edge.from.location}`, `want: ${edge.spec || '*'}`);\n    const placementType = canPlace.canPlace === CONFLICT ? canPlace.canPlaceSelf : canPlace.canPlace; // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict();\n      } // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n\n\n      this.pruneDedupable(target);\n      return;\n    } // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n\n\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({\n          parent: target,\n          target: p\n        });\n        return;\n      }\n    } // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n\n    const virtualRoot = dep.parent;\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? {\n        target: dep.target,\n        realpath: dep.realpath\n      } : {})\n    });\n    this.oldDep = target.children.get(this.name);\n\n    if (this.oldDep) {\n      this.replaceOldDep();\n    } else {\n      this.placed.parent = target;\n    } // if it's an overridden peer dep, warn about it\n\n\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict();\n    } // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n\n\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false);\n    } // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n\n\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false); // only walk the direct children of the ones we kept\n\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false);\n          }\n        }\n      }\n    } // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n\n\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue;\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name); // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n\n      if (!peer) {\n        continue;\n      } // overridden peerEdge, just accept what's there already\n\n\n      if (!peer.satisfies(peerEdge)) {\n        continue;\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge\n      }));\n    }\n  }\n\n  replaceOldDep() {\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = [];\n\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n    }\n\n    this.placed.replace(this.oldDep);\n    this.pruneForReplacement(this.placed, oldDeps);\n  }\n\n  pruneForReplacement(node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n\n      for (const dep of set) {\n        invalidDeps.add(dep);\n      }\n    } // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n\n\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid); // now just delete whatever's left, because it's junk\n\n    for (const dep of deps) {\n      dep.root = null;\n    }\n  } // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n\n\n  pruneDedupable(node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid);\n\n      for (const node of deps) {\n        node.root = null;\n      }\n\n      return;\n    }\n\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => a.location.localeCompare(b.location, 'en');\n\n      const children = [...node.children.values()].sort(nodeSort);\n\n      for (const child of children) {\n        this.pruneDedupable(child);\n      }\n\n      const fsChildren = [...node.fsChildren].sort(nodeSort);\n\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort);\n\n        for (const child of children) {\n          this.pruneDedupable(child);\n        }\n      }\n    }\n  }\n\n  get conflictOk() {\n    return this.force || !this.isMine && !this.strictPeerDeps;\n  }\n\n  get isMine() {\n    const {\n      edge\n    } = this.top;\n    const {\n      from: node\n    } = edge;\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true;\n    }\n\n    if (!edge.peer) {\n      return false;\n    } // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n\n\n    let hasPeerEdges = false;\n\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true;\n        continue;\n      }\n\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true;\n      }\n    }\n\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  warnPeerConflict() {\n    this.edge.overridden = true;\n    const expl = this.explainPeerConflict();\n    log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  }\n\n  failPeerConflict() {\n    const expl = this.explainPeerConflict();\n    throw Object.assign(new Error('could not resolve'), expl);\n  }\n\n  explainPeerConflict() {\n    const {\n      edge,\n      dep\n    } = this.top;\n    const {\n      from: node\n    } = edge;\n    const curNode = node.resolve(edge.name);\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge)\n    };\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge);\n      expl.peerConflict = this.current && this.current.explain(this.edge);\n    } else {\n      expl.current = curNode && curNode.explain();\n\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf;\n\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge)\n            };\n            break;\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge)\n        };\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine\n    } = this;\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine\n    }); // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n\n    return expl;\n  }\n\n  getStartNode() {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from;\n    return deepestNestingTarget(from, this.name);\n  }\n\n  get top() {\n    return this.parent ? this.parent.top : this;\n  }\n\n  isVulnerable(node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  get allChildren() {\n    const set = new Set(this.children);\n\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n\n    return [...set];\n  }\n\n}\n\nmodule.exports = PlaceDep;","map":{"version":3,"sources":["/home/adalaber/Escritorio/ADALAB/evaluaciones/modulo-3-evaluacion-final-dunayari/node_modules/npm/node_modules/@npmcli/arborist/lib/place-dep.js"],"names":["log","require","deepestNestingTarget","CanPlaceDep","KEEP","CONFLICT","debug","Link","gatherDepSet","peerEntrySets","PlaceDep","constructor","options","dep","edge","parent","name","canPlace","target","placed","preferDedupe","force","explicitRequest","updateNames","auditReport","legacyBundling","strictPeerDeps","legacyPeerDeps","globalStyle","Object","assign","children","peerConflict","checks","Map","place","to","error","includes","isVulnerable","start","getStartNode","canPlaceSelf","ancestry","targetEdge","edgesOut","get","isTop","peer","cpd","set","errors","length","rp","resolveParent","isProjectRoot","current","conflictOk","failPeerConflict","warnPeerConflict","placeInTree","Error","silly","location","version","description","from","package","_id","spec","placementType","valid","pruneDedupable","p","matches","virtualRoot","pkg","resolved","integrity","isLink","realpath","oldDep","replaceOldDep","satisfies","node","root","inventory","query","isDescendantOf","kid","values","peerEdge","overridden","push","oldDeps","entries","has","e","replace","pruneForReplacement","invalidDeps","Set","filter","map","add","deps","descend","canDedupe","nodeSort","a","b","localeCompare","sort","child","fsChildren","topNode","isMine","top","isWorkspace","hasPeerEdges","edgesIn","keys","expl","explainPeerConflict","warn","curNode","resolve","code","explain","cps","conflictChildren","allChildren","grandchild","module","exports"],"mappings":"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","sourcesContent":["// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst log = require('proc-log')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\nconst CanPlaceDep = require('./can-place-dep.js')\nconst {\n  KEEP,\n  CONFLICT,\n} = CanPlaceDep\nconst debug = require('./debug.js')\n\nconst Link = require('./link.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\n\nclass PlaceDep {\n  constructor (options) {\n    const {\n      dep,\n      edge,\n      parent = null,\n    } = options\n    this.name = edge.name\n    this.dep = dep\n    this.edge = edge\n    this.canPlace = null\n\n    this.target = null\n    this.placed = null\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    } = parent || options\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    })\n\n    this.children = []\n    this.parent = parent\n    this.peerConflict = null\n\n    this.checks = new Map()\n\n    this.place()\n  }\n\n  place () {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks,\n    } = this\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to &&\n        !edge.error &&\n        !explicitRequest &&\n        !updateNames.includes(edge.name) &&\n        !this.isVulnerable(edge.to)) {\n      return\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode()\n\n    let canPlace = null\n    let canPlaceSelf = null\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name)\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest,\n      })\n      checks.set(target, cpd)\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd\n      } else {\n        break\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent\n        if (rp && rp.isProjectRoot) {\n          break\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf,\n    })\n    this.current = edge.to\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict()\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict()\n        return\n      }\n\n      this.canPlace = canPlaceSelf\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree()\n  }\n\n  placeInTree () {\n    const {\n      dep,\n      canPlace,\n      edge,\n    } = this\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree')\n      })\n      return\n    }\n\n    const { target } = canPlace\n\n    log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description,\n      `for: ${this.edge.from.package._id || this.edge.from.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    const placementType = canPlace.canPlace === CONFLICT\n      ? canPlace.canPlaceSelf\n      : canPlace.canPlace\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict()\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target)\n      return\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({ parent: target, target: p })\n        return\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? { target: dep.target, realpath: dep.realpath } : {}),\n    })\n\n    this.oldDep = target.children.get(this.name)\n    if (this.oldDep) {\n      this.replaceOldDep()\n    } else {\n      this.placed.parent = target\n    }\n\n    // if it's an overridden peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict()\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false)\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false)\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false)\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue\n      }\n\n      // overridden peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge,\n      }))\n    }\n  }\n\n  replaceOldDep () {\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = []\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n    }\n    this.placed.replace(this.oldDep)\n    this.pruneForReplacement(this.placed, oldDeps)\n  }\n\n  pruneForReplacement (node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set) {\n        invalidDeps.add(dep)\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable (node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid)\n      for (const node of deps) {\n        node.root = null\n      }\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => a.location.localeCompare(b.location, 'en')\n\n      const children = [...node.children.values()].sort(nodeSort)\n      for (const child of children) {\n        this.pruneDedupable(child)\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children) {\n          this.pruneDedupable(child)\n        }\n      }\n    }\n  }\n\n  get conflictOk () {\n    return this.force || (!this.isMine && !this.strictPeerDeps)\n  }\n\n  get isMine () {\n    const { edge } = this.top\n    const { from: node } = edge\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true\n    }\n\n    if (!edge.peer) {\n      return false\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true\n        continue\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  warnPeerConflict () {\n    this.edge.overridden = true\n    const expl = this.explainPeerConflict()\n    log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  failPeerConflict () {\n    const expl = this.explainPeerConflict()\n    throw Object.assign(new Error('could not resolve'), expl)\n  }\n\n  explainPeerConflict () {\n    const { edge, dep } = this.top\n    const { from: node } = edge\n    const curNode = node.resolve(edge.name)\n\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge),\n    }\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge)\n      expl.peerConflict = this.current && this.current.explain(this.edge)\n    } else {\n      expl.current = curNode && curNode.explain()\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge),\n            }\n            break\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge),\n        }\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine,\n    } = this\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine,\n    })\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl\n  }\n\n  getStartNode () {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from\n    return deepestNestingTarget(from, this.name)\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  isVulnerable (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n}\n\nmodule.exports = PlaceDep\n"]},"metadata":{},"sourceType":"script"}